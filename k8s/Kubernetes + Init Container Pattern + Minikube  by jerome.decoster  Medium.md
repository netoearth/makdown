> Testing the **Init Container Kubernetes Pattern** with **Minikube**.

**The Goal**

-   Run a **voting application** using an **express website** and **redis**
-   Run locally using **docker images** and **docker-compose**
-   Run locally using **minikube**

![](https://miro.medium.com/max/635/1*OUfOSpUmdx4xe4_emoXdVQ.png)

## Setup the project

Get the code from this [github repository](https://github.com/jeromedecoster/k8s-init-container-pattern) :

## The Init Container pattern

The **Init Container pattern** is the first of the structural models described in the [Bilgin Ibryam and Roland Huß book](https://www.oreilly.com/library/view/kubernetes-patterns/9781492050278/)

![](https://miro.medium.com/max/250/0*J1BcccBg3B676SOJ.jpg)

Kubernetes manages pods instead of containers and pods encapsulate containers. **A pod may contain one or more containers**.

A pod that contains one container refers to a **single container pod** and it is the **most common kubernetes use case**.

A pod that contains Multiple co-related containers refers to a **multi-container pod**.

[Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) are the containers that should **run and complete before the startup of the main container** in the pod. It provides a separate lifecycle for the initialization.

-   `Init containers` always run to completion.
-   It is possible to have **1 or more** `init containers`.
-   Each init container must complete successfully before the next one starts.
-   So, `init containers` are **executed sequentially, one after another**.

In the field of container orchestration, the **ability to wait for an initialization phase is essential**.

The [initContainers property](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#init-containers-in-use) is therefore **part of the syntax of kubernetes manifests** :

`Init containers` are used to :

-   **Wait** for a service to be available before launching a container that depends on it
-   **Installing** software
-   **Setup** a database
-   Setting permissions on the file system

## Run the projet locally

The project is a simple voting application. A website that uses a Redis database.

![](https://miro.medium.com/max/700/0*0weUnTtf2T7W5A9G.png)

To test our application we **launch redis** via a docker image :

This command executes this script :

```
$ docker run \    --rm \    --name redis \    --publish 6379:6379 \    redis:alpine
```

We will interact with redis in a new terminal window :

## Test the website in development mode (without redis)

Make sure Redis isn’t already running by **closing all previous instances**.

We will test the website **without Redis being active**.

```
# run local website using npm - dev mode (livereload + nodemon)$ make npm
```

The site launches with a **connection error** :

```
env.NODE_ENV: developmentenv.WEBSITE_PORT: 3000env.REDIS_HOST: 127.0.0.1listening on port 3000[ioredis] Unhandled error event: Error: connect ECONNREFUSED 127.0.0.1:6379    at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1158:16)
```

This error is generated by [trying to connect](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/vote/index.js) to the Redis instance :

You can end the process with `Ctrl+C`

## Test the website in development mode (with redis)

We will now launch the applications **in the correct order**, via different terminal windows :

```
# run redis alpine docker image$ make redis# run local website using npm - dev mode (livereload + nodemon)$ make npm
```

The output is :

```
env.NODE_ENV: developmentenv.WEBSITE_PORT: 3000env.REDIS_HOST: 127.0.0.1listening on port 3000
```

We open [http://localhost:3000](http://localhost:3000/)

![](https://miro.medium.com/max/700/0*TQcoiQ7rbX0tq7qy.png)

The test is conclusive. Both processes can be terminated.

## Local test with docker-compose

Before testing in minikube, it’s a good idea to use `docker-compose` to **orchestrate the containers that make up the application locally**. It’s a good step.

The [docker-compose.yml](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/docker-compose.dev.yml) file is quite simple :

We execute the following command :

```
# run the project using docker-compose (same as redis + npm)$ make compose-dev
```

This command runs this script :

```
$ export COMPOSE_PROJECT_NAME=k8s_init_container$ docker-compose \    --file docker-compose.dev.yml \    up \    --remove-orphans \    --force-recreate \    --build \    --no-deps
```

The output is :

```
redis_1  | 1:C 31 Mar 2022 08:25:22.753 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1  | 1:C 31 Mar 2022 08:25:22.753 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started# ...vote_1   | env.NODE_ENV: developmentvote_1   | env.WEBSITE_PORT: 4000vote_1   | env.REDIS_HOST: undefinedvote_1   | listening on port 4000
```

We open [http://localhost:4000](http://localhost:4000/)

![](https://miro.medium.com/max/700/0*xpWPBV237s6Cevhj.png)

The test is conclusive. We can complete the process.

## Using mikinube

We start minikube :

```
$ minikube start --driver=docker
```

If minikube won’t start with a `PROVIDER_DOCKER_NOT_RUNNING` error or another error, try [a hard reset](https://stackoverflow.com/a/54994074) :

```
$ minikube delete -p minikube
```

We check the context :

```
$ kubectl config current-contextminikube
```

We launch the **Kubernetes dashboard** in a new terminal window :

```
# new terminal window$ minikube dashboard
```

![](https://miro.medium.com/max/700/0*3DQb78ohDiw193ks.png)

To be able to [use our local docker images within minikube](https://stackoverflow.com/a/56392747) it is imperative to :

1.  Target the **local docker registry**
2.  **Rebuild the docker images** in this registry
3.  use the `imagePullPolicy: Never` **attribute** in kubernetes manifests

```
# 1. target the local docker registry$ eval $(minikube -p minikube docker-env)# 2. rebuild the docker images in this registry# /!\ must be in the same terminal window than previous command$ make docker-build# ...Successfully tagged site:latest
```

The [attribute is visible](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/k8s/vote.yaml) below :

We **create the kubernetes namespace** with the [ns.yaml](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/k8s/ns.yaml) template :

```
$ kubectl apply -f k8s/ns.yamlnamespace/k8s-init-container created
```

![](https://miro.medium.com/max/700/0*ForvSRSV0gfQtGOZ.png)

We launch the **vote application** with the [vote.yaml](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/k8s/vote.yaml) template :

```
$ kubectl apply -f k8s/vote.yamldeployment.apps/vote createdservice/vote-svc created
```

Note that the **Redis instance has not been started**.

We can query the `init-vote` **container logs** :

```
$ kubectl logs -l app=vote -c init-vote -n k8s-init-containernc: bad address 'redis-svc'Waiting for redis-svc
```

The `init-vote` container is a **busybox that runs a shell script that loops until the redis service is available** :

The current status shown in the **Replica Sets panel** :

![](https://miro.medium.com/max/700/0*Htro-MLmLfJxwWRT.png)

In a new terminal window we connect **within the cluster via another busybox** :

```
$ kubectl run -i --tty --rm busybox \    --image=busybox \    --namespace=k8s-init-container \    --restart=Never \    -- sh/
```

The current status shown in the **Pods panel** :

![](https://miro.medium.com/max/700/0*Ukrr0RM2ij_MrM35.png)

We will **query the state** of the `vote-svc` service from our busybox :

![](https://miro.medium.com/max/700/0*EkGjOm68HBoDBZUz.png)

We can use [nc](https://linuxhandbook.com/nc-command/) :

```
/ nc -vz vote-svc 9000# processus completed but nothing is returned
```

Nothing is returned but the **processus is completed**

If we **test a bad name**, we received an error :

```
/ nc -vz vote-something 9000nc: bad address 'vote-something'
```

If we **test a bad port**, we received nothing :

```
/ nc -vz vote-svc 90# processus not completed ... waiting
```

Nothing is returned and the **processus is not completed**

We can use [nslookup](https://linuxhandbook.com/nslookup-command/) :

```
/ nslookup -type=srv vote-svc.k8s-init-container.svc.cluster.localServer:         10.96.0.10Address:        10.96.0.10:53vote-svc.k8s-init-container.svc.cluster.local   service = 0 100 9000 vote-svc.k8s-init-container.svc.cluster.local
```

If we **test a bad name**, we received :

```
/ nslookup -type=srv vote-something.k8s-init-container.svc.cluster.localServer:         10.96.0.10Address:        10.96.0.10:53** server cant find vote-something.k8s-init-container.svc.cluster.local: NXDOMAIN
```

In a new terminal window we now **launch the redis instance** with the [redis.yaml](https://github.com/jeromedecoster/k8s-init-container-pattern/blob/master/k8s/redis.yaml) template :

```
$ kubectl apply -f k8s/redis.yaml
```

We test the service with [nc](https://linuxhandbook.com/nc-command/) :

```
/ nc -vz redis-svc 6379redis-svc (10.107.142.90:6379) open
```

Or with [nslookup](https://linuxhandbook.com/nslookup-command/) :

```
/ # nslookup -type=srv redis-svc.k8s-init-container.svc.cluster.localServer:         10.96.0.10Address:        10.96.0.10:53redis-svc.k8s-init-container.svc.cluster.local  service = 0 100 6379 redis-svc.k8s-init-container.svc.cluster.local
```

To test our site we **search the access URL** via the following command :

It is possible to use **get it directly** like this :

```
$ minikube service --url vote-svc --namespace k8s-init-containerhttp://192.168.49.2:31000
```

By opening the URL we see that the website is working correctly :

![](https://miro.medium.com/max/700/0*pXgiWwTzvOob53X4.png)

The demonstration is over, we can **destroy our resources**.