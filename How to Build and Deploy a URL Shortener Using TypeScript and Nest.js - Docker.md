_At Docker, we’re incredibly proud of our vibrant, diverse and creative community. From time to time, we feature cool contributions from the community on our blog to highlight some of the great work our community does. Are you working on something awesome with Docker? Send your contributions to Ajeet Singh Raina (@ajeetraina) on the_ [_Docker Community Slack_](https://dockercommunity.slack.com/join/shared_invite/zt-m8y5jl0m-kFllVvYPlexvNd6qvGRNhw#/) _and we might feature your work!_

Over the last five years, TypeScript’s [popularity has surged](https://octoverse.github.com/#top-languages-over-the-years) among enterprise developers. In [Stack Overflow’s 2022 Developer Survey](https://survey.stackoverflow.co/2022/#most-loved-dreaded-and-wanted-language-want), TypeScript ranked third in the “most wanted” category. Stack Overflow reserves this distinction for developers who aren’t developing with a specific language or technology, but have expressed interest in doing so.

TypeScript’s incremental adoption is attributable to enhancements in developer code quality and comprehensibility. Overall, Typescript encourages developers to thoroughly document their code and inspires greater confidence through ease of use. TypeScript offers [every modern JavaScript feature](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) while introducing powerful concepts like [](https://www.google.com/url?q=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html%23interfaces&sa=D&source=editors&ust=1656756778132687&usg=AOvVaw3JseJpz5cVaKCEfNevXDYC)[interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces), [unions,](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#unions) and [intersection types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types). It improves developer productivity by clearly displaying syntax errors during compilation, rather than letting things fail at runtime.

However, remember that every programming language comes with certain drawbacks, and TypeScript is no exception. Long compilation times and a steeper learning curve for new JavaScript users are most noteworthy. The good news is that TypeScript’s pros outweigh its cons for ideal use cases. We’ll tackle one of those now. 

## Building Your Application

In this tutorial, you’ll learn how to build a basic URL shortener from scratch using TypeScript and Nest.

First, you’ll create a basic application in Nest without using Docker. You’ll see how the application lets you build a simple URL shortening service in Nest and TypeScript, with a Redis backend. Next, you’ll learn how Docker Compose can help you jointly run a Nest.js, TypeScript, and Redis backend to power microservices. Let’s jump in.

## Getting Started

The following key components are essential to completing this walkthrough:

-   [Node.js](https://nodejs.org/en/)
-   [NPM](https://www.npmjs.com/)
-   [VS Code](https://code.visualstudio.com/docs/remote/containers)
-   [Docker Desktop](https://docs.docker.com/desktop/) 

Before starting, make sure you have [Node installed on your system](https://nodejs.org/en/download/). Then, follow these steps to build a simple web application with TypeScript.

## Creating a Nest Project

Nest is currently the fastest growing server-side development framework in the JavaScript ecosystem. It’s ideal for writing scalable, testable, and loosely-coupled applications. Nest provides a level of abstraction above common Node.js frameworks and exposes their APIs to the developer. Under the hood, Nest makes use of robust HTTP server frameworks like [Express](https://expressjs.com/) (the default) and can optionally use [Fastify](https://github.com/fastify/fastify) as well! It supports databases like PostgreSQL, MongoDB, and MySQL. NestJS is heavily influenced by Angular, React, and Vue — while offering dependency injection right out of the box.

For first-time users, we recommend creating a new project with the Nest CLI. First, enter the following command to install the Nest CLI.

<table><tbody><tr><td><p>1</p></td><td><div><p><code>npm </code><code>install</code> <code>-g @nestjs</code><code>/cli</code></p></div></td></tr></tbody></table>

Next, let’s create a new Nest.js project directory called `backend`.

It’s time to populate the directory with the initial core Nest files and supporting modules. From your new backend directory, run Nest’s bootstrapping command. We’ll call our new application `link-shortener`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p></td><td><div><p><code>nest new link-shortener</code></p><p><code>&amp;</code></p><p><code>CREATE link-shortener/.eslintrc.js (665 bytes)</code></p><p><code>CREATE link-shortener/.prettierrc (51 bytes)</code></p><p><code>CREATE link-shortener</code><code>/README</code><code>.md (3340 bytes)</code></p><p><code>CREATE link-shortener</code><code>/nest-cli</code><code>.json (118 bytes)</code></p><p><code>CREATE link-shortener</code><code>/package</code><code>.json (1999 bytes)</code></p><p><code>CREATE link-shortener</code><code>/tsconfig</code><code>.build.json (97 bytes)</code></p><p><code>CREATE link-shortener</code><code>/tsconfig</code><code>.json (546 bytes)</code></p><p><code>CREATE link-shortener</code><code>/src/app</code><code>.controller.spec.ts (617 bytes)</code></p><p><code>CREATE link-shortener</code><code>/src/app</code><code>.controller.ts (274 bytes)</code></p><p><code>CREATE link-shortener</code><code>/src/app</code><code>.module.ts (249 bytes)</code></p><p><code>CREATE link-shortener</code><code>/src/app</code><code>.service.ts (142 bytes)</code></p><p><code>CREATE link-shortener</code><code>/src/main</code><code>.ts (208 bytes)</code></p><p><code>CREATE link-shortener</code><code>/test/app</code><code>.e2e-spec.ts (630 bytes)</code></p><p><code>CREATE link-shortener</code><code>/test/jest-e2e</code><code>.json (183 bytes)</code></p><p><code>? Which package manager would you &amp;</code></p><p><code>❯ npm</code></p><p><code>&nbsp;&nbsp;</code><code>yarn</code></p><p><code>&nbsp;&nbsp;</code><code>pnpm</code></p></div></td></tr></tbody></table>

All three packages managers are usable, but we’ll choose `npm` for the purposes of this walkthrough.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p></td><td><div><p><code>Which package manager would you &amp;</code></p><p><code>&amp;</code></p><p><code>&amp;</code></p><p><code>&amp;</code></p><p><code>$ </code><code>cd</code> <code>link-shortener</code></p><p><code>$ npm run start</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Thanks </code><code>for</code> <code>installing Nest &amp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Please consider donating to our </code><code>open</code> <code>collective</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>to help us maintain this package.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p></div></td></tr></tbody></table>

Once the command is executed successfully, it creates a new `link-shortener` project directory with node modules and a few other boilerplate files. It also creates a new `src/` directory populated with several core files as shown in the following directory structure:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></td><td><div><p><code>tree -L 2 -a</code></p><p><code>.</code></p><p><code>└── link-shortener</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── dist</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── .eslintrc.js</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── .gitignore</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── nest-cli.json</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── node_modules</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── package.json</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── package-lock.json</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── .prettierrc</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── README.md</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── src</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── </code><code>test</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>├── tsconfig.build.json</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>└── tsconfig.json</code></p><p><code>5 directories, 9 files</code></p></div></td></tr></tbody></table>

Let’s look at the core files ending with `.ts` (TypeScript) under `/src` directory:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>src % tree</code></p><p><code>.</code></p><p><code>├── app.controller.spec.ts</code></p><p><code>├── app.controller.ts</code></p><p><code>├── app.module.ts</code></p><p><code>├── app.service.ts</code></p><p><code>└── main.ts</code></p><p><code>0 directories, 5 files</code></p></div></td></tr></tbody></table>

Nest embraces modularity. Accordingly, two of the most important Nest app components are controllers and providers. Controllers determine how you handle incoming requests. They’re responsible for accepting incoming requests, performing some kind of operation, and returning the response. Meanwhile, providers are extra classes which you can inject into the controllers or to certain providers. This grants various supplemental functionality. We always recommend reading up on [providers](https://docs.nestjs.com/providers) and [controllers](https://docs.nestjs.com/controllers) to better understand how they work.

The `app.module.ts` is the root module of the application and bundles up a couple of controllers and providers that the controller uses.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>cat app.module.ts&nbsp;</code></p><p><code>import</code> <code>{ Module } from </code><code>'@nestjs/common'</code><code>;</code></p><p><code>import</code> <code>{ AppController } from </code><code>'./app.controller'</code><code>;</code></p><p><code>import</code> <code>{ AppService } from </code><code>'./app.service'</code><code>;</code></p><p><code>@Module({</code></p><p><code>&nbsp;&nbsp;</code><code>imports: [],</code></p><p><code>&nbsp;&nbsp;</code><code>controllers: [AppController],</code></p><p><code>&nbsp;&nbsp;</code><code>providers: [AppService],</code></p><p><code>})</code></p><p><code>export</code> <code>class</code> <code>AppModule {}</code></p></div></td></tr></tbody></table>

As shown in the above file, AppModule is just an empty class. Nest’s `@Module` decorator is responsible for providing the config that lets Nest build a functional application from it.

First, `app.controller.ts` exports  a basic controller with a single route. The `app.controller.spec.ts` is the unit test for the controller. Second, `app.service.ts` is a basic service with a single method. Third, `main.ts` is the entry file of the application. It bootstraps the application by calling `NestFactory.create`, then starts the new application by having it listen for inbound HTTP requests on `port 3000.`

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>import</code> <code>{ NestFactory } from </code><code>'@nestjs/core'</code><code>;</code></p><p><code>import</code> <code>{ AppModule } from </code><code>'./app.module'</code><code>;</code></p><p><code>async</code> <code>function</code> <code>bootstrap() {</code></p><p><code>&nbsp;&nbsp;</code><code>const app = </code><code>await</code> <code>NestFactory.create(AppModule);</code></p><p><code>&nbsp;&nbsp;</code><code>await</code> <code>app.listen(3000);</code></p><p><code>}</code></p><p><code>bootstrap();</code></p></div></td></tr></tbody></table>

## Running the Application

Once the installation is completed, run the following command to start your application:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p></td><td><div><p><code>npm run start</code></p><p><code>&gt; link-shortener@0.0.1 start</code></p><p><code>&gt; nest start</code></p><p><code>[Nest] 68686&nbsp; - 05/31/2022, 5:50:59 PM&nbsp;&nbsp;&nbsp;&nbsp; LOG [NestFactory] Starting Nest application...</code></p><p><code>[Nest] 68686&nbsp; - 05/31/2022, 5:50:59 PM&nbsp;&nbsp;&nbsp;&nbsp; LOG [InstanceLoader] AppModule dependencies initialized +24ms</code></p><p><code>[Nest] 68686&nbsp; - 05/31/2022, 5:50:59 PM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RoutesResolver] AppController {/}: +4ms</code></p><p><code>[Nest] 68686&nbsp; - 05/31/2022, 5:50:59 PM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RouterExplorer] Mapped {/, GET} route +2ms</code></p><p><code>[Nest] 68686&nbsp; - 05/31/2022, 5:50:59 PM&nbsp;&nbsp;&nbsp;&nbsp; LOG [NestApplication] Nest application successfully started +1ms</code></p></div></td></tr></tbody></table>

This command starts the app with the HTTP server listening on the port defined in the `src/main.ts` file. Once the application is successfully running, open your browser and navigate to `http://localhost:3000`. You should see the “Hello World!” message:

##  ![Image5](https://www.docker.com/wp-content/uploads/2022/07/image5-730x214.png)

### Add a Repository

A repository is a layer that is in charge of storing stuff. Here, we would want a repository layer to store the mapping between the hashes and their original URLs.

Let’s first create an interface for the repository. Create a file named `app.repository.ts` and fill it up as follows:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p></td><td><div><p><code>import</code> <code>{ Observable } from </code><code>'rxjs'</code><code>;</code></p><p><code>export</code> <code>interface</code> <code>AppRepository {</code></p><p><code>&nbsp;&nbsp;</code><code>put(hash: string, url: string): Observable&lt;string&gt;;</code></p><p><code>&nbsp;&nbsp;</code><code>get(hash: string): Observable&lt;string&gt;;</code></p><p><code>}</code></p><p><code>export</code> <code>const AppRepositoryTag = </code><code>'AppRepository'</code><code>;</code></p><p><code>&lt;/pre&gt;</code></p><p><code>&amp;nbsp;</code></p><p><code>&lt;p </code><code>class</code><code>=</code><code>"c9"</code><code>&gt;&lt;span </code><code>class</code><code>=</code><code>"c6"</code><code>&gt;Now, </code><code>let</code><code>'s create a simple repository that stores the mappings in a hashmap in the memory. Create a file named&nbsp;&lt;code&gt;app.repository.hashmap.ts&lt;/code&gt;:&lt;/span&gt;&lt;/p&gt;</code></p><p><code>&lt;pre&gt;</code></p><p><code>import { AppRepository } from '</code><code>./app.repository</code><code>';</code></p><p><code>import { Observable, of } from '</code><code>rxjs';</code></p><p><code>export</code> <code>class</code> <code>AppRepositoryHashmap </code><code>implements</code> <code>AppRepository {</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>readonly hashMap: Map&lt;string, string&gt;;</code></p><p><code>&nbsp;&nbsp;</code><code>constructor() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>.hashMap = </code><code>new</code> <code>Map&lt;string, string&gt;();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>get(hash: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>of(</code><code>this</code><code>.hashMap.get(hash));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>put(hash: string, url: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>of(</code><code>this</code><code>.hashMap.set(hash, url).get(hash));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table>

Now, let’s instruct Nest.js that if one asked for `AppRepositoryTag` provide them with `AppRepositoryHashMap`. First, let’s do it in the `app.module.ts`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>import</code> <code>{ Module } from </code><code>'@nestjs/common'</code><code>;</code></p><p><code>import</code> <code>{ AppController } from </code><code>'./app.controller'</code><code>;</code></p><p><code>import</code> <code>{ AppService } from </code><code>'./app.service'</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryTag } from </code><code>'./app.repository'</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryHashmap } from </code><code>'./app.repository.hashmap'</code><code>;</code></p><p><code>@Module({</code></p><p><code>&nbsp;&nbsp;</code><code>imports: [],</code></p><p><code>&nbsp;&nbsp;</code><code>controllers: [AppController],</code></p><p><code>&nbsp;&nbsp;</code><code>providers: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AppService,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{ provide: AppRepositoryTag, useClass: AppRepositoryHashmap },</code></p><p><code>&nbsp;&nbsp;</code><code>],</code></p><p><code>})</code></p><p><code>export</code> <code>class</code> <code>AppModule {}</code></p></div></td></tr></tbody></table>

Let’s now add a new test for our new endpoint in `app.service.spec.ts`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></td><td><div><p><code>import</code> <code>{ Test, TestingModule } from </code><code>"@nestjs/testing"</code><code>;</code></p><p><code>import</code> <code>{ AppService } from </code><code>"./app.service"</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryTag } from </code><code>"./app.repository"</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryHashmap } from </code><code>"./app.repository.hashmap"</code><code>;</code></p><p><code>import</code> <code>{ mergeMap, tap } from </code><code>"rxjs"</code><code>;</code></p><p><code>describe(</code><code>'AppService'</code><code>, () =&gt; {</code></p><p><code>&nbsp;&nbsp;</code><code>let</code> <code>appService: AppService;</code></p><p><code>&nbsp;&nbsp;</code><code>beforeEach(</code><code>async</code> <code>() =&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const app: TestingModule = </code><code>await</code> <code>Test.createTestingModule({</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>providers: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{ provide: AppRepositoryTag, useClass: AppRepositoryHashmap },</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AppService,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}).compile();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>appService = app.get&lt;AppService&gt;(AppService);</code></p><p><code>&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;</code><code>describe(</code><code>'retrieve'</code><code>, () =&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>it(</code><code>'should retrieve the saved URL'</code><code>, done =&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const url = </code><code>'docker.com'</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>appService.shorten(url)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.pipe(mergeMap(hash =&gt; appService.retrieve(hash)))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.pipe(tap(retrieved =&gt; expect(retrieved).toEqual(url)))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.subscribe({ complete: done })</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;</code><code>});</code></p><p><code>});</code></p></div></td></tr></tbody></table>

Before running our tests, let’s implement the function in `app.service.ts`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p></td><td><div><p><code>import</code> <code>{ Inject, Injectable } from </code><code>'@nestjs/common'</code><code>;</code></p><p><code>import</code> <code>{ map, Observable } from </code><code>'rxjs'</code><code>;</code></p><p><code>import</code> <code>{ AppRepository, AppRepositoryTag } from </code><code>'./app.repository'</code><code>;</code></p><p><code>@Injectable()</code></p><p><code>export</code> <code>class</code> <code>AppService {</code></p><p><code>&nbsp;&nbsp;</code><code>constructor(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@Inject(AppRepositoryTag) </code><code>private</code> <code>readonly appRepository: AppRepository,</code></p><p><code>&nbsp;&nbsp;</code><code>) {}</code></p><p><code>&nbsp;&nbsp;</code><code>getHello(): string {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>'Hello World!'</code><code>;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>shorten(url: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const hash = Math.random().toString(36).slice(7);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>this</code><code>.appRepository.put(hash, url).pipe(map(() =&gt; hash));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>retrieve(hash: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>this</code><code>.appRepository.get(hash);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table>

Run these tests once more to confirm that everything passes, before we begin storing the data in a real database.

## Add a Database

So far, we’re just storing our mappings in memory. That’s fine for testing, but we’ll need to store them somewhere more centralized and durable in production. We’ll use Redis, a popular key-value store [available on Docker Hub](https://hub.docker.com/r/redis/redis-stack).

Let’s install this Redis client by running the following command from the `backend/link-shortener` directory:

<table><tbody><tr><td><p>1</p></td><td><div><p><code>npm </code><code>install</code> <code>redis@4.1.0 --save</code></p></div></td></tr></tbody></table>

Inside `/src`, create a new version of the AppRepository interface that uses Redis. We’ll call this file `app.repository.redis.ts`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p></td><td><div><p><code>import</code> <code>{ AppRepository } from </code><code>'./app.repository'</code><code>;</code></p><p><code>import</code> <code>{ Observable, from, mergeMap } from </code><code>'rxjs'</code><code>;</code></p><p><code>import</code> <code>{ createClient, RedisClientType } from </code><code>'redis'</code><code>;</code></p><p><code>export</code> <code>class</code> <code>AppRepositoryRedis </code><code>implements</code> <code>AppRepository {</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>readonly redisClient: RedisClientType;</code></p><p><code>&nbsp;&nbsp;</code><code>constructor() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const host = process.env.REDIS_HOST || </code><code>'redis'</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const port = +process.env.REDIS_PORT || 6379;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>.redisClient = createClient({</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>url: `redis:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>from(</code><code>this</code><code>.redisClient.connect()).subscribe({ error: console.error });</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>.redisClient.on(</code><code>'connect'</code><code>, () =&gt; console.log(</code><code>'Redis connected'</code><code>));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>.redisClient.on(</code><code>'error'</code><code>, console.error);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>get(hash: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>from(</code><code>this</code><code>.redisClient.get(hash));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>put(hash: string, url: string): Observable&lt;string&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>from(</code><code>this</code><code>.redisClient.set(hash, url)).pipe(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mergeMap(() =&gt; from(</code><code>this</code><code>.redisClient.get(hash))),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table>

Finally, it’s time to change the provider in `app.module.ts` to our new Redis repository from the in-memory version:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>import</code> <code>{ Module } from </code><code>'@nestjs/common'</code><code>;</code></p><p><code>import</code> <code>{ AppController } from </code><code>'./app.controller'</code><code>;</code></p><p><code>import</code> <code>{ AppService } from </code><code>'./app.service'</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryTag } from </code><code>'./app.repository'</code><code>;</code></p><p><code>import</code> <code>{ AppRepositoryRedis } from </code><code>"./app.repository.redis"</code><code>;</code></p><p><code>@Module({</code></p><p><code>&nbsp;&nbsp;</code><code>imports: [],</code></p><p><code>&nbsp;&nbsp;</code><code>controllers: [AppController],</code></p><p><code>&nbsp;&nbsp;</code><code>providers: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AppService,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{ provide: AppRepositoryTag, useClass: AppRepositoryRedis },</code></p><p><code>&nbsp;&nbsp;</code><code>],</code></p><p><code>})</code></p><p><code>export</code> <code>class</code> <code>AppModule {}</code></p></div></td></tr></tbody></table>

## Finalize the Backend

Head back to `app.controller.ts` and create another endpoint for redirect:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p></td><td><div><p><code>import</code> <code>{ Body, Controller, Get, Param, Post, Redirect } from </code><code>'@nestjs/common'</code><code>;</code></p><p><code>import</code> <code>{ AppService } from </code><code>'./app.service'</code><code>;</code></p><p><code>import</code> <code>{ map, Observable, of } from </code><code>'rxjs'</code><code>;</code></p><p><code>interface</code> <code>ShortenResponse {</code></p><p><code>&nbsp;&nbsp;</code><code>hash: string;</code></p><p><code>}</code></p><p><code>interface</code> <code>ErrorResponse {</code></p><p><code>&nbsp;&nbsp;</code><code>error: string;</code></p><p><code>&nbsp;&nbsp;</code><code>code: number;</code></p><p><code>}</code></p><p><code>@Controller()</code></p><p><code>export</code> <code>class</code> <code>AppController {</code></p><p><code>&nbsp;&nbsp;</code><code>constructor(</code><code>private</code> <code>readonly appService: AppService) {}</code></p><p><code>&nbsp;&nbsp;</code><code>@Get()</code></p><p><code>&nbsp;&nbsp;</code><code>getHello(): string {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>this</code><code>.appService.getHello();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>@Post(</code><code>'shorten'</code><code>)</code></p><p><code>&nbsp;&nbsp;</code><code>shorten(@Body(</code><code>'url'</code><code>) url: string): Observable&lt;ShortenResponse | ErrorResponse&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!url) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>of({ error: `No url provided. Please provide </code><code>in</code> <code>the body. E.g. {</code><code>'url'</code><code>:</code><code>'<a href="https://google.com/">https://google.com</a>'</code><code>}`, code: 400 });</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>this</code><code>.appService.shorten(url).pipe(map(hash =&gt; ({ hash })));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>@Get(</code><code>':hash'</code><code>)</code></p><p><code>&nbsp;&nbsp;</code><code>@Redirect()</code></p><p><code>&nbsp;&nbsp;</code><code>retrieveAndRedirect(@Param(</code><code>'hash'</code><code>) hash): Observable&lt;{ url: string }&gt; {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>this</code><code>.appService.retrieve(hash).pipe(map(url =&gt; ({ url })));</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table>

[Click here](https://github.com/dockersamples/link-shortener-typescript) to access the code previously developed for this example.

## Containerizing the TypeScript Application

[Docker](https://docs.docker.com/get-started/) helps you containerize your TypeScript app, letting you bundle together your complete TypeScript application, runtime, configuration, and OS-level dependencies. This includes everything needed to ship a cross-platform, multi-architecture web application. 

Let’s see how you can easily run this app inside a Docker container using a Docker Official Image. First, you’ll need to [download Docker Desktop](https://www.docker.com/products/docker-desktop/). Docker Desktop accelerates the image-building process while making useful images more discoverable. Complete the installation process once your download is finished.

Docker uses a [Dockerfile](https://docs.docker.com/engine/reference/builder/) to specify an image’s “layers.” Each layer stores important changes building upon the base image’s standard configuration. Create the following empty `Dockerfile` in your Nest project.

`touch Dockerfile`

Use your favorite text editor to open this `Dockerfile`. You’ll then need to define your base image. Let’s also quickly create a directory to house our image’s application code. This acts as the working directory for your application:

`WORKDIR /app`

The following `COPY` instruction copies the files from the host machine to the container image:

`COPY . .`

Finally, this closing line tells Docker to compile and run your application packages:

`CMD["npm", "run", "start:dev"]`

Here’s your complete `Dockerfile`:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><div><p><code>FROM node:16</code></p><p><code>COPY . .</code></p><p><code>WORKDIR </code><code>/app</code></p><p><code>RUN npm </code><code>install</code></p><p><code>EXPOSE 3000</code></p><p><code>CMD [</code><code>"npm"</code><code>, </code><code>"run"</code><code>, </code><code>"start:dev"</code><code>]</code></p></div></td></tr></tbody></table>

You’ve effectively learned how to build a `Dockerfile` for a sample TypeScript app. Next, let’s see how to create an associated Docker Compose file for this application. Docker Compose is a tool for defining and running multi-container Docker applications. With Compose, you’ll use a YAML file to configure your services. Then, with a single command, you can create and start every service from your configuration.

## Defining Services Using a Compose File

It’s time to define your services in a Docker Compose file:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p></td><td><div><p><code>services:</code></p><p><code>&nbsp;&nbsp;</code><code>redis:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>image:</code> <code>'redis/redis-stack'</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ports:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>'6379:6379'</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>'8001:8001'</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>networks:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>urlnet</code></p><p><code>&nbsp;&nbsp;</code><code>dev:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>build:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context:</code> <code>./backend/link-shortener</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>dockerfile:</code> <code>Dockerfile</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>environment:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>REDIS_HOST:</code> <code>redis</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>REDIS_PORT:</code> <code>6379</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ports:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>'3000:3000'</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>volumes:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>'./backend/link-shortener:/app'</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>depends_on:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>redis</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>networks:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>-</code> <code>urlnet</code></p><p><code>networks:</code></p><p><code>&nbsp;&nbsp;</code><code>urlnet:</code></p></div></td></tr></tbody></table>

Your example application has the following parts:

-   Two services backed by Docker images: your frontend `dev` app and your backend database `redis`
-   The `redis/redis-stack` Docker image is an extension of Redis that adds modern data models and processing engines to provide a complete developer experience. We use `port 8001` for RedisInsight — a visualization tool for understanding and optimizing Redis data.
-   The frontend, accessible via `port 3000`
-   The `depends_on` parameter, letting you create your backend service before the frontend service starts
-   One persistent volume, attached to the backend
-   The environmental variables for your Redis database

Once you’ve stopped the frontend and backend services that we ran in the previous section, let’s build and start our services using the `docker-compose up` command:

<table><tbody><tr><td><p>1</p></td><td><div><p><code>docker compose up -d –build</code></p></div></td></tr></tbody></table>

**Note:** If you’re using Docker Compose v1, the command line syntax is `docker-compose` with a hyphen. If you’re using v2, which ships with Docker Desktop, the hyphen is omitted and `docker compose` is correct. 

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><div><p><code>docker compose </code><code>ps</code></p><p><code>NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORTS</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp;&nbsp; </code><code>"docker-entrypoint.s…"</code>&nbsp;&nbsp; <code>dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:3000-&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;3000</code><code>/tcp</code></p><p><code>link-shortener-js-redis-1&nbsp;&nbsp; </code><code>"/entrypoint.sh"</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0:6379-&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;6379</code><code>/tcp</code><code>, 0.0.0.0:8001-&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;8001</code><code>/tcp</code></p></div></td></tr></tbody></table>

Just like that, you’ve created and deployed your TypeScript URL shortener! You can use this in your browser like before. If you visit the application at https://localhost:3000, you should see a friendly “Hello World!” message. Use the following `curl` command to shorten a new link:

Here’s your response:

This hash may differ on your machine. You can use it to redirect to the original link. Open any web browser and visit https://localhost:3000/l6r71d to access Docker’s website.

## Viewing the Redis Keys

You can view the Redis keys with the RedisInsight tool by visiting https://localhost:8001.

 ![Image1](https://www.docker.com/wp-content/uploads/2022/07/image1.png)

## Viewing the Compose Logs

You can use `docker compose logs -f` to check and view your Compose logs:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p></td><td><div><p><code>[6:17:19 AM] Starting compilation </code><code>in</code> <code>watch</code> <code>mode...</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; |</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [6:17:22 AM] Found 0 errors. Watching </code><code>for</code> <code>file</code> <code>changes.</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; |</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [NestFactory] Starting Nest application...</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [InstanceLoader] AppModule dependencies initialized +21ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RoutesResolver] AppController {/}: +3ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RouterExplorer] Mapped {/, GET} route +1ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RouterExplorer] Mapped {</code><code>/shorten</code><code>, POST} route +0ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [RouterExplorer] Mapped {/:</code><code>hash</code><code>, GET} route +1ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | [Nest] 31&nbsp; - 06</code><code>/18/2022</code><code>, 6:17:23 AM&nbsp;&nbsp;&nbsp;&nbsp; LOG [NestApplication] Nest application successfully started +1ms</code></p><p><code>link-shortener-js-dev-1&nbsp;&nbsp;&nbsp; | Redis connected</code></p></div></td></tr></tbody></table>

You can also leverage the Docker Dashboard to view your container’s ID and easily access or manage your application:

 ![Image3](https://www.docker.com/wp-content/uploads/2022/07/image3.png)

You can also inspect important logs via the Docker Dashboard:

 ![Image2](https://www.docker.com/wp-content/uploads/2022/07/image2.png)

## Conclusion

Congratulations! You’ve successfully learned how to build and deploy a URL shortener with TypeScript and Nest. Using a single YAML file, we demonstrated how Docker Compose helps you easily build and deploy a TypeScript-based URL shortener app in seconds. With just a few extra steps, you can apply this tutorial while building applications with much greater complexity.

Happy coding.